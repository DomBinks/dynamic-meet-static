module Utils where

import Control.Applicative
import Data.Char
import qualified Data.Map as Map
import qualified Data.List as List

------------------------------------ General -----------------------------------

-- Tokens scanned by the scanner
data Token = Num Double       -- number
           | Op Operator      -- operator
           | Par Parenthesis  -- parenthesis
           | Str String       -- string
           | Nme String       -- variable/function name
           | Bool Bool        -- boolean
           | Tp TypeConstant  -- type
           | SCol             -- ;
           | Col              -- :
           | Eq               -- =
           | Cma              -- ,
           | Kword Keyword    -- keyword e.g. if, else, etc.
           deriving (Eq, Show)

-- Operators scanned by the scanner
data Operator = Plus         -- +
              | Minus        -- -
              | Times        -- *
              | Divide       -- / (float division)
              | FloorDivide  -- // (floor division)
              | Modulo       -- %
              | Power        -- ^
              | Less         -- <
              | LessEq       -- <=
              | Greater      -- >
              | GreaterEq    -- >=
              | Eql          -- ==
              | NotEq        -- ~=
              | Not          -- not
              | And          -- and
              | Or           -- or
              deriving (Eq, Show)

-- Parentheses scanned by the scanner
data Parenthesis = Open      -- (
                 | Closed    -- )
                 | SqOpen    -- [
                 | SqClosed  -- ]
                 | CrOpen    -- {
                 | CrClosed  -- }
                 deriving (Eq, Show)
                
-- Keyword scanned by the scanner
data Keyword = If     -- if
             | Then   -- then
             | ElseIf -- elseif
             | Else   -- else
             | End    -- end
             | While  -- while
             | Do     -- do
             | For    -- for
             | Func   -- function
             | Ret    -- return
             | Brk    -- break
             | Prt    -- print
             | Rpt    -- repeat
             | Utl    -- until
             deriving (Eq, Show)

-- AST generated by the parser
data AST = Register Int -- used by code generation
         | Number Double
         | Name String
         | String String
         | Boolean Bool
         | Nil
         | Type Type
         | Statements [AST] -- list of statements
         | Assignment AST AST AST -- name, type, value
         | BinOp BinaryOperator AST AST -- 2 operands
         | UnOp UnaryOperator AST -- 1 operand
         | IfThen AST AST -- condition and body
         | IfElse AST AST AST -- condition, if body, else body
         | WhileLoop AST AST -- condition and body
         | ForLoop AST AST AST AST -- initialisation, condition, step, body
         | Function AST [AST] AST -- name, arguments, body
         | Return AST -- return value
         | Arg AST AST -- name and type
         | Call AST [AST] -- name and arguments
         | Break
         | Print AST -- print value
         | RepeatUntil AST AST -- body and condition
         | ArrayIndex AST AST -- name and index
         | ArrayInit [AST] -- initial values
         deriving (Eq, Show)

-- Type scanned by the scanner and parsed by the parser
data Type = TyVar String -- Type variable
          | TyCon TypeConstant -- Type constant
          | TyArr [Type] Type -- Arrow type for functions
          | TyArray Type Int -- Array
          | TyBlank -- No type specified in code / not enough information
          | Typeless -- Construct doesn't have a type e.g. assignment
          deriving Eq

-- Show their LLVM type if applicable
instance Show Type where
  show (TyVar s) = s
  show (TyCon c) = show c
  show (TyArr args ret) = (show args) ++ " " ++ (show ret)
  show (TyArray c i) = "[" ++ (show i) ++ " x " ++ (show c) ++ "]"
  show TyBlank = "TyBlank"
  show Typeless = "Typeless"

-- Type constants for primitive types
data TypeConstant = TNil           -- nil
                  | TBoolean       -- boolean
                  | TNumber        -- number
                  | TString        -- string
                  deriving Eq

-- Show their LLVM type
instance Show TypeConstant where
  show TNil = "i1*"
  show TNumber = "double"
  show TBoolean = "i1"
  show TString = "i8*"

-- Binary operators parsed by the parser
data BinaryOperator = Addition       -- +
                    | Subtraction    -- - (binary)
                    | Multiplication -- *
                    | Division       -- /
                    | FloorDivision  -- //
                    | Remainder      -- %
                    | Exponentiation -- ^
                    | GreaterThan    -- <
                    | GreaterEqual   -- <=
                    | LessThan       -- >
                    | LessEqual      -- >=
                    | Equal          -- ==
                    | NotEqual       -- ~=
                    | BoolOr         -- or
                    | BoolAnd        -- and
                    deriving (Eq, Show)

-- Unary operators parsed by the parser
data UnaryOperator = Negation -- - (unary)
                   | BoolNot  -- not
                   deriving (Eq, Show)

-- Reserved list of names that can't be given to variables or funcions as
-- they're used in the LLVM IR template file
reservedList :: [String]
reservedList = ["printf", "fmod", "main"]

-- Get the register the string is stored in
getStringRegister :: String -> String
getStringRegister str = '@':(head (show str)):'-':(tail (show str))

-- Placeholder for break statements that will be replaced with branch instructions
breakPlaceholder :: String
breakPlaceholder = "BREAK"

----------------------------------- Scanner ------------------------------------

-- Scanner for scanning a program String into a list of Tokens
newtype Scanner a = S(String -> Maybe (a, String))

-- Define Scanner as an instance of the Functor type class
instance Functor Scanner where
  -- fmap :: (a -> b) -> Scanner a -> Scanner b
  fmap f sa = S(\s -> case scan sa s of
                       Nothing      -> Nothing
                       Just (a, s') -> Just (f a, s'))

-- Define Scanner as an instance of the Applicative type class
instance Applicative Scanner where
  -- pure :: a -> Scanner a
  pure a = S(\s -> Just (a, s))

  -- (<*>) :: Scanner (a -> b) -> Scanner a -> Scanner b
  sab <*> sa = S(\s -> case scan sab s of
                         Nothing -> Nothing
                         Just(ab, s') -> scan (fmap ab sa) s')

-- Define Scanner as an instance of the Monad type class
instance Monad Scanner where
  -- (>>=) :: Scanner a -> (a -> Scanner b) -> Scanner b
  sa >>= f = S(\s -> case scan sa s of
                       Nothing      -> Nothing
                       Just (a, s') -> scan (f a) s')

-- Define Scanner as an instance of the Alternative type class
instance Alternative Scanner where
  -- empty :: Scanner a
  empty = S(\s -> Nothing)

  -- (<|>) :: Scanner a -> Scanner a -> Scanner a
  s1 <|> s2 = S(\s -> case scan s1 s of
                        Nothing      -> scan s2 s
                        Just (a, s') -> Just (a, s'))

-- Remove the scanning function from the Scanner dummy constructor
scan :: Scanner a -> String -> Maybe (a, String)
scan (S sa) s = sa s

-- Scan the front Char from the String
sFront :: Scanner Char
sFront = S(\s -> case s of
                 []     -> Nothing
                 (c:cs) -> Just (c, cs))

-- Scan the front Char from the String if the given predicate holds
sSatisfy :: (Char -> Bool) -> Scanner Char
sSatisfy p = do
              c <- sFront
              if p c then return c else Control.Applicative.empty

-- Scan the front Char from the String if it matches the given Char
sChar :: Char -> Scanner Char
sChar c = do
           x <- sSatisfy (== c)
           return x

-- Scan a String from the front of the String if it matches the given String
sString :: String -> Scanner String
sString [] = return []
sString (x:xs) = do
                  sChar x
                  sString xs
                  return (x:xs)

-- Scan the whitespace from the front of a String
sSpace :: Scanner ()
sSpace = do
          many (sSatisfy isSpace)
          return ()

------------------------------------ Parser ------------------------------------

-- Parser for parsing Lists of Tokens into an AST
newtype Parser a = P([Token] -> Maybe (a, [Token]))

-- Define Parser as an instance of the Functor type class
instance Functor Parser where
  -- fmap :: (a -> b) -> Parser a -> Parser b
  fmap f pa = P(\ts -> case parse pa ts of
                         Nothing       -> Nothing
                         Just (a, ts') -> Just (f a, ts'))

-- Define Parser as an instance of the Applicative type class
instance Applicative Parser where
  -- pure :: a -> Parser a
  pure x = P(\ts -> Just (x, ts))

  -- (<*>) :: Parser (a->b) -> Parser a -> Parser b
  pf <*> pa = P(\ts -> case parse pf ts of
                         Nothing       -> Nothing
                         Just (f, ts') -> parse (fmap f pa) ts')

-- Define Parser as an instance of the Monad type class
instance Monad Parser where
  -- (>>=) :: Parser a -> (a -> Parser b) -> Parser b
  pa >>= f = P(\ts -> case parse pa ts of
                        Nothing       -> Nothing
                        Just (a, ts') -> parse (f a) ts')

-- Define Parser as an instance of the Alternative type class
instance Alternative Parser where
  -- empty :: Parser a
  empty = P(\ts -> Nothing)

  -- (<|>) :: Parser a -> Parser a -> Parser a
  p1 <|> p2 = P(\ts -> case parse p1 ts of
                         Nothing        -> parse p2 ts
                         Just (a, ts')  -> Just (a, ts'))

-- Remove the parsing function from the Parser dummy constructor
parse :: Parser a -> [Token] -> Maybe (a, [Token])
parse (P fa) s = fa s

-- Parse the front Token from the list of Tokens
pFront :: Parser Token
pFront = P(\ts -> case ts of
                   []    -> Nothing
                   (t:s) -> Just (t, s))

-- Parse the front Token from the list of Tokens if the given predicate holds
pSatisfy :: (Token -> Bool) -> Parser Token
pSatisfy p = do
              t <- pFront
              if p t then return t else Control.Applicative.empty

-- Parse the front Token from the list of Tokens if it matches the given Token
pToken :: Token -> Parser Token
pToken t = pSatisfy (== t)

-- Given a list of names and a prefix, recursively rename the names to begin
-- with the prefix
renamePrefix :: [String] -> String -> AST -> AST
renamePrefix vars pre (Name n) =
  if elem n vars then (Name (pre ++ n)) else (Name n)
renamePrefix vars pre (Statements xs) =
  (Statements (map (renamePrefix vars pre) xs))
renamePrefix vars pre (Assignment n t v) =
  (Assignment (renamePrefix vars pre n) t (renamePrefix vars pre v))
renamePrefix vars pre (BinOp op l r) =
  (BinOp op (renamePrefix vars pre l) (renamePrefix vars pre r))
renamePrefix vars pre (UnOp op x) =
  (UnOp op (renamePrefix vars pre x))
renamePrefix vars pre (IfThen c b) =
  (IfThen (renamePrefix vars pre c) (renamePrefix vars pre b))
renamePrefix vars pre (IfElse c b e) =
  (IfElse
     (renamePrefix vars pre c)
     (renamePrefix vars pre b)
     (renamePrefix vars pre e))
renamePrefix vars pre (WhileLoop c b) =
  (WhileLoop (renamePrefix vars pre c) (renamePrefix vars pre b))
renamePrefix vars pre (ForLoop i c s b) =
  (ForLoop
     (renamePrefix vars pre i)
     (renamePrefix vars pre c)
     (renamePrefix vars pre s)
     (renamePrefix vars pre b))
renamePrefix vars pre (Return e) =
  (Return (renamePrefix vars pre e))
renamePrefix vars pre (Arg n t) =
  (Arg (renamePrefix vars pre n) (renamePrefix vars pre t))
renamePrefix vars pre (Call n args) =
  (Call (renamePrefix vars pre n) (map (renamePrefix vars pre) args))
renamePrefix vars pre (Print v) =
  (Print (renamePrefix vars pre v))
renamePrefix vars pre (RepeatUntil b c) =
  (WhileLoop (renamePrefix vars pre b) (renamePrefix vars pre c))
renamePrefix vars pre (ArrayIndex n i) =
  (ArrayIndex (renamePrefix vars pre n) (renamePrefix vars pre i))
renamePrefix vars pre (ArrayInit vs) =
  (ArrayInit (map (renamePrefix vars pre) vs))
renamePrefix _ _ (Function _ _ _) = error "Nested functions aren't allowed"
renamePrefix _ _ x = x

--------------------------------- Type Checker ---------------------------------

data Scheme = Forall [String] Type   -- Type scheme
type Envt a = Map.Map String a       -- Environment type constructor
type TypeEnvt = Envt Type            -- Type environment
type SchemeEnvt = Envt Scheme        -- Type scheme environment
type TypeConEnvt = Envt TypeConstant -- Type constant environment
type Subst = [(String, Type)]        -- Substitution

-- State used by type checker
-- Int is used to track the next type variable number to use
type TypeState = (TypeEnvt, SchemeEnvt, Int) 

-- Type checker state transformer
newtype TST a = TST(TypeState -> (a, TypeState)) 

-- Define TST as an instance of the Functor type class
instance Functor TST where
  -- fmap :: (a -> b) -> TST a -> TST b
  fmap f sta = TST(\s -> let (a, s') = appTST sta s in (f a, s'))

-- Define TST as an instance of the Applicative type class
instance Applicative TST where
  -- pure :: a -> TST a
  pure a = TST(\s -> (a, s))

  -- (<*>) :: TST (a -> b) -> TST a -> TST b
  stf <*> sta = TST(\s ->
                    let
                      (f, s') = appTST stf s
                      (a, s'') = appTST sta s'
                    in
                      (f a, s''))

-- Define TST as an instance of the Monad type class
instance Monad TST where
  -- (>>=) :: TST a -> (a -> TST b) -> TST b
  sta >>= f = TST(\s -> let (a, s') = appTST sta s in appTST (f a) s')

-- Apply the type checker state transformer to the provided TypeState
appTST :: TST a -> TypeState -> (a, TypeState)
appTST (TST sta) s = sta s

-- Get a fresh type variable
freshVar :: TST Type
freshVar = TST(\(env, fenv, i) -> (TyVar (show i), (env, fenv, i+1)))

-- Get the type environment
getEnvTST :: TST TypeEnvt
getEnvTST = TST(\(env, fenv, i) -> (env, (env, fenv, i)))

-- Set the type environment
setEnvTST :: TypeEnvt -> TST ()
setEnvTST e = TST(\(_, fenv, i) -> ((), (e, fenv, i)))

-- Add the variable/function with its type to the type environment
addEnv :: String -> Type -> TST ()
addEnv var typ = TST(\(env, fenv, i) -> ((), (Map.insert var typ env, fenv, i)))

-- Try to get the type of the variable/function from the type environment
getMType :: String -> TST (Maybe Type)
getMType var = TST(\(env, fenv, i) -> case (Map.lookup var env) of
                                        (Just t) -> ((Just t), (env, fenv, i))
                                        Nothing -> (Nothing, (env, fenv, i)))

-- Get the type scheme for the function
getOpSch :: String -> TST Scheme
getOpSch op =
  TST(\(env, fenv, i) -> case (Map.lookup op fenv) of
                           (Just sch) -> (sch, (env, fenv, i))
                           Nothing -> error ("Unable to find type scheme for " ++ op))

-- Change any TyArray with length fnd to have length rep
setArrayLength :: Int -> Int -> TST ()
setArrayLength fnd rep = do
                           env <- getEnvTST
                           let
                             lstEnv = Map.toList env
                             lstEnv' =
                               map (\(n, t) -> (n, replaceType fnd rep t)) lstEnv
                           setEnvTST (Map.fromList lstEnv')

-- Replace length fnd with length rep in a TyArray in the given type
replaceType :: Int -> Int -> Type -> Type
replaceType fnd rep (TyArr args ret) = TyArr (map (replaceType fnd rep) args)
                                         (replaceType fnd rep ret)
replaceType fnd rep (TyArray e l) = TyArray (replaceType fnd rep e)
                                      (if fnd == l then rep else l)
replaceType _ _ t = t

-------------------------------- Code Generator --------------------------------

data GenState = GenState -- State used by code generator
  { reg :: Int -- next register number
  , lbl :: Int -- next label number
  , env :: TypeEnvt -- type environment
  , code :: [String] -- code for functions and strings
  }

-- Code generator state transformer
newtype GST a = GST(GenState -> (a, GenState))

-- Define GST as an instance of the Functor type class
instance Functor GST where
  -- fmap :: (a -> b) -> GST a -> GST b
  fmap f sta = GST(\s -> let (a, s') = appGST sta s in (f a, s'))

-- Define GST as an instance of the Applicative type class
instance Applicative GST where
  -- pure :: a -> GST a
  pure a = GST(\s -> (a, s))

  -- (<*>) :: GST (a -> b) -> GST a -> GST b
  stf <*> sta = GST(\s ->
                   let
                     (f, s') = appGST stf s
                     (a, s'') = appGST sta s'
                   in
                     (f a, s''))

-- Define GST as an instance of the Monad type class
instance Monad GST where
  -- (>>=) :: GST a -> (a -> GST b) -> GST b
  sta >>= f = GST(\s -> let (a, s') = appGST sta s in appGST (f a) s')

-- Apply the code generator state transformer to the provided GenState
appGST :: GST a -> GenState -> (a, GenState)
appGST (GST sta) s = sta s

-- Get a fresh register name
freshReg :: GST String
freshReg = GST(\s -> ("%r" ++ show (reg s), s {reg = (reg s)+1}))

-- Get a fresh label and the register for the label
freshLbl :: GST (String, String)
freshLbl = GST(\s -> let
                       l = '-':(show (lbl s))
                       l' = '%':l
                     in
                       ((l++":", l'), s {lbl = (lbl s)+1}))

-- Get the type constant of a given variable/function from the type environment
getTypeConstant :: String -> GST TypeConstant
getTypeConstant n = GST(\s -> (case (Map.lookup n (env s)) of
                                (Just (TyCon t)) -> t
                                (Just (TyArr _ (TyCon retT))) -> retT
                                (Just (TyArray (TyCon t) _)) -> t
                                _ -> error ("Unable to get type constant of " ++ n), s))

-- Get the type of the given variable/function from the type environment
getType :: String -> GST Type
getType n = GST(\s -> (case (Map.lookup n (env s)) of
                         (Just t) -> t
                         _ -> error ("Unable to get type of " ++ n), s))

-- Get the type environment
getEnvGST :: GST TypeEnvt
getEnvGST = GST(\s -> (env s, s))

-- Get the return type of the given function from the type environment
getReturnType :: String -> GST Type
getReturnType n = GST(\s -> (case (Map.lookup n (env s)) of
                              (Just (TyArr _ t)) -> t
                              _ -> error ("Unable to get return type of " ++ n), s))

-- Add function code to the end of the code in the state
addFunctionCode :: [String] -> GST ()
addFunctionCode c = GST(\s -> ((), s {code = (code s)++c}))

-- Add a String constant to the start of the code in the state
addString :: String -> GST ()
addString str =
  GST(\s -> if not $ elem s' (code s) -- check the String isn't already in the code
            then ((), s {code = s':(code s)}) -- add the String to the code
            else ((), s)) -- do nothing
  where
    -- Line of code to declare the String
    s' = getStringRegister str
       ++ " = constant [" ++ (show ((length str) + 1)) ++ " x i8] c\""
       ++ str ++ "\\00\""